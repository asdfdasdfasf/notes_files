---
title: Java基础知识
cover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1603983928098&di=79fabf49d6e8ab3cc8a4013e35915e5c&imgtype=0&src=http%3A%2F%2Fc2.hoopchina.com.cn%2Fuploads%2Fstar%2Fevent%2Fimages%2F200105%2Fab31082ad6c8121fba58220ea18cdb4f003242ef.jpg
toc_number: true
---

# Java 基础知识总结

## 环境搭建问题

1. 一个 java 文件中可以出现定义多个 class
2. public 类不是必须的可以没有
3. 在源文件中定义一个 class 必定会对应生成一个 class
4. public 的类可以没有，但如果有的话，public 修饰的类名必须和源文件名保持一致。
5. public 的类有也只能有 1 个。
6. 一个 java 文件中可以没有 public 类，当程序有多个类且有 main 方法时，加载谁的.class 文件，谁就执行

## 常用的组合键方式

1. 复制 ctrl + c
2. 粘贴 ctrl + v
3. 剪切 ctrl + x
4. 保存 ctrl + s
5. 撤销 ctrl + z
6. 重做 ctrl + y
7. 回到行首：home 键
8. 回到行尾：end 键
9. 当光标在行尾，怎么选中一行？shift + home 键
10. 当光标在行首，怎么选中一行？shift + end 键
11. 回到文件头：ctrl + home
12. 回到文件尾：ctrl + end
13. 在 idea 中添加方法注释/\*\* 然后 Enter 键

## 标识符和关键字

#### 什么是标识符

1. 标识符只能由数字、字母（包括中文）、下划线\_、美元符号\$组成，

   不能含有其它符号。

2. 标识符不能以数字开头

3. 关键字不能做标识符。例如：public class static void 这些蓝色的字体

   都是关键字，关键字是不能做标识符的。

4. 标识符是严格区分大小写的。大写 A 和小写 a 不一样

5. 标识符理论上是没有长度限制的。

   类名是标识符，标识符“中”**不能有空格**

#### 具体的命名规范是哪些？

1. 规范 1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）

2. 规范 2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低...）

3. 驼峰有利于单词与单词之间很好的进行分隔，BiaoShiFuTest，这个很好，一眼就能看出来是 4 个单词。

4. 规范 3：类名、接口名有特殊要求，类名和接口名首字母大写，后面每个单词首字母大写，StudentTest、UserTest ，这是类名、接口名。

5. 规范 4：变量名、方法名有特殊要求变量名和方法名首字母小写，后面每个单词首字母大写。nianLing（NianLing 这样就不符合了。）mingZi（MingZi 这样也不符合了。）

6. 规范 5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。

   USER_AGE ：用户年龄

   MATH_PI：固定不变的常量 3.1415926.....。

   **<u>注意：</u>**虽然 java 中的标识符严格区分大小写

   但是对于类名来说，如果一个 java 源文件中同时出现了：A 类和 a 类

   那么谁在前就生成谁。大家以后最好不要让类名“相同”。

   最好类名是不同的。

7. 问题：创建一个 java 文件，起名 123.java 可以吗？

   可以，完全可以，在 windows 操作系统中文件名叫做：123.java 没毛病。

   123 其实并不是标识符。只是一个文件名。

   只不过在 123.java 文件中无法定义 public 的类。

8. **_在一个方法体中，如果一个变量只是声明了没有进行赋值的话，那么这个变量将不能够被访问_**

## 变量

1. 注意：在 java 语言中“数据”被称为“字面量”。10 1.23 true false 'a' "abc"

   以上这些都是数据，在程序中都被叫做“字面量”。

2. 字面量可以分为很多种类：

   整数型字面量：1 2 3 100 -100 -20 ....

   浮点型字面量：1.3 1.2 3.14.....

   布尔型字面量：true、false 没有其它值了，表示真和假,true 表示真，false 表示假

   字符型字面量：'a'、'b'、'中'

   字符串型字面量："abc"、"a"、"b"、"中国"

   其中字符型和字符串型都是描述了现实世界中的文字：

   需要注意的是：

   所有的字符型只能使用单引号括起来。

   所有的字符串型只能使用双引号括起来。

   字符型一定是单个字符才能成为“字符型”

   在语法级别上怎么区分字符型和字符串型？

   主要看是双引号还是单引号。

   单引号的一定是字符型。

   双引号的一定是字符串型。

3. 1. 变量根据出现的位置进行划分：
   2. 在方法体当中声明的变量：局部变量。
   3. 在方法体之外，类体内声明的变量：成员变量。

   java 中有一个很重要的原则：

   就近原则。（不仅 java 中是这样，其它编程语言都有这个原则。）

   哪个离我近，就访问哪个。

## 数据类型

1. 字符型：char

   1、char 占用 2 个字节。

   2、char 的取值范围：[0-65535]

   3、char 采用 unicode 编码方式。

   4、char 类型的字面量使用单引号括起来。

   5、char 可以存储一个汉字。

2. 浮点型：float 4 个字节 double 8 个字节

3. byte 1 个字节 最大值 127

4. short 2 个字节 最大值 32767

5. int 4 个字节 2147483647 是 int 最大值，超了这个范围可以使用 long 类型

   ***

   ###### 在 java 中有一条非常重要的结论：

    在任何情况下，整数型的“字面量/数据”默认被当做 int 类型处理。（记住就行）

   如果希望该“整数型字面量”被当做 long 类型来处理，需要在“字面量”后面添加 L/l

   建议使用大写 L，因为小写 l 和 1 傻傻分不清。

   ###### 例如：

   ```java
   		// 在java中，整数型字面量一上来编译器就会将它看做int类型
   		// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。
   		// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648
   		// 只不过2147483648本身已经超出了int范围。
   		// 错误: 整数太大
   		//long e = 2147483648;
   		// 怎么解决这个问题呢？
   		long e = 2147483648L;
   		System.out.println(e);

   ```

   ##### 计算机数字的存储方式：

   ```
   	1、计算机在任何情况下都只能识别二进制
   	2、计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”
   		计算机采用补码形式存储数据的原因是：补码形式效率最高。
   	3、什么是补码呢？
   		实际上是这样的，二进制有：原码 反码 补码
   	4、记住：
   		对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。
   			int i = 1;
   			对应的二进制原码：00000000 00000000 00000000 00000001
   			对应的二进制反码：00000000 00000000 00000000 00000001
   			对应的二进制补码：00000000 00000000 00000000 00000001
   		对于一个负数来说：二进制原码、反码、补码是什么关系呢？
   			byte i = -1;
   			对应的二进制原码：10000001
   			对应的二进制反码（符号位不变，其它位取反）：11111110
   			对应的二进制补码（反码+1）：11111111
   	5、分析 byte b = (byte)150;
   		这个b是多少？
   			int类型的4个字节的150的二进制码是什么？
   				00000000 00000000 00000000 10010110
   			将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：
   				10010110

   		千万要注意：计算机永远存储的都是二进制补码形式。也就是说上面
   		10010110 这个是一个二进制补码形式，你可以采用逆推导的方式推算出
   		这个二进制补码对应的原码是啥！！！！！！
   			10010110 ---> 二进制补码形式
   			10010101 ---> 二进制反码形式
   			11101010 ---> 二进制原码形式

   ```

   ###### _整数是否能字节赋值给 char_ ？

   ```
   	2、char x = 97;
   		这个java语句是允许的，并且输出的结果是'a'
   		经过这个测试得出两个结论：
   			第一个结论：当一个整数赋值给char类型变量的时候，会自动转换成char字符型，
   			最终的结果是一个字符。
   			第二个结论：当一个整数没有超出byte short char的取值范围的时候，
   			这个整数可以直接赋值给byte short char类型的变量。

   ```

   ###### 在 java 中规定，任何一个浮点数都会被当做 double 来处理

   ```java
   	//如果想让这个浮点型字面量被当做float类型来处理，那么
   	//请在字面量后面添加F/f。
   		//1.0 那么1.0默认被当做double类型处理。
   		//1.0F 这才是float类型。（1.0f）
   	//分析：
   		// 这个可以吗？
   		//错误: 不兼容的类型: 从double转换到float可能会有损失
   		float f = 3.14;
   	//修改：
   	          float f = 3.14f;
   		 float f = 3.14F;
   	// 第二种方式：强制类型转换，但可能损失精度。谨慎使用。
   			float f = (float)3.14;
   			System.out.println(f);
   强制转换可能会带来精度丢失问题
        要想让以上的程序编译通过，必须加强制类型转换符
   	// 虽然编译通过了，但是可能精度损失。
   	// 300这个int类型对应的二进制：00000000 00000000 00000001 00101100
   	// byte占用1个字节，砍掉前3个字节，结果是：00101100 (44)
   	byte b = (byte)300;
   	System.out.println(b); // 44
   ```


   ```

   ###### 结论：byte,char,short 做混合运算的时候，各自先转换成 int 再做运算

   ```java
   	char c1 = 'a';
   			byte b = 1;

   			// 注意：这里的"+"是负责求和的
   			System.out.println(c1 + b); // 98

   			// 错误: 不兼容的类型: 从int转换到short可能会有损失
   			//short s = c1 + b; // 编译器不知道这个加法最后的结果是多少。只知道是int类型。

   			// 这样修改行吗？
   			//错误: 不兼容的类型: 从int转换到short可能会有损失
   			//short s = (short)c1 + b;

   			short s = (short)(c1 + b);

   			//short k = 98;

   			int a = 1;
   			//错误: 不兼容的类型: 从int转换到short可能会有损失
   			// short x = 1; 可以
   			short x = a; // 不可以，编译器只知道a是int类型，不知道a中存储的是哪个值。
   			System.out.println(x);

   ```

   ###### 结论：当多种数据类型做混合运算的时候，最终的结果类型是"最大容量"对应的类型。

   ​ char+short+byte 这个除外，因为 char +short +byte 混合运算的时候，会各自转换成 int 再做运算

## 运算符

###### java 中如何输入：

```java
	java.util.Scanner s = new java.util.Scanner(System.in);
		//接收一个整数怎么办？
			int num = s.nextInt();

		//接收一个字符串怎么办？
			String str = s.next();
	import java.util.Scanner;
Scanner s = new Scanner(System.in);
```

###### 很重要得语法机制：

```java
//使用扩展赋值运算符的时候，永远都不会改变运算结果类型。
			byte x = 100;
			x += 1;
//x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。
//不管后面是多大的数字。
// 研究：
		// i += 10 和 i = i + 10 真的是完全一样吗？
		// 答案：不一样，只能说相似，其实本质上并不是完全相同。
		byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
		System.out.println(x); // 100

		// 分析：这个代码是否能够编译通过？
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？

		// 使用扩展赋值运算符可以吗？
		// 可以的，所以得出结论：x += 1 和 x = x + 1不一样。
		// 其实 x += 1 等同于：x = (byte)(x + 1);
		x += 1;
		System.out.println(x); // 101

		// 早就超出byte的取值范围了。
		x += 199; // x = (byte)(x + 199);
		System.out.println(x); // 44 （当然会自动损失精度了。）

```

###### 在 java 中+号运算符

```
		1、+ 运算符在java语言中有两个作用。
			作用1：求和
			作用2：字符串拼接

		2、什么时候求和？什么时候进行字符串的拼接呢？
			当 + 运算符两边都是数字类型的时候，求和。
			当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。

         3、一定要记住：字符串拼接完之后的结果还是一个字符串。
```

###### switch 只支持 int 和 String 类型

```java
// 错误: 不兼容的类型: 从long转换到int可能会有损失
		long x = 100L;
		switch(x){

}
```

## java 中的方法

#### main 方法不需要程序员手动调用，是由 jvm 调用的

```
		但是除了main方法之外其他的方法，都需要程序员
		手动调用，方法只有调用的时候才会执行，方法不调用
		是不会执行的。
         // 方法定义在类体当中。
         // 方法定义的先后顺序没有关系。都可以。
```

#### 方法的定义和相关的语法机制

```java
		[修饰符列表] 返回值类型 方法名(形式参数列表){
			方法体;
		}
		注意：
			[] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。
			方法体由Java语句构成。
			方法定义之后需要去调用，不调用是不会执行的。

		1.1、关于修饰符列表：
			修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static
			后面你就理解应该怎么写了。
          		1.2、关于返回值类型：

			第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据
			类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short
			int long float double boolean char String......

			第二：什么是返回值？
				返回值一般指的是一个方法执行结束之后的结果。
				结果通常是一个数据，所以被称为“值”，而且还叫
				“返回值”。
				方法就是为了完成某个特定的功能，方法结束之后
				大部分情况下都是有一个结果的，而体现结果的一般
				都是数据。数据得有类型。这就是返回值类型。

				main{
					// 调用a方法
					a();..如果a方法执行结束之后有返回值，这个返回值返回给main了。
				}

				a(){}

				方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。

			第三：当一个方法执行结束不返回任何值的时候，返回值
			类型也不能空白，必须写上void关键字。所以void表示该
			方法执行结束后不返回任何结果。

			第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用
			"return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句
			那么编译器会报错。
				return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。

			第五：只要有“return”关键字的语句执行，当前方法必然结束。
			return只要执行，当前所在的方法结束，记住：不是整个程序结束。

			第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的
			语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前
			方法的。

			第七：除了void之外，剩下的都必须有“return 值;”这样的语句。

		1.3、方法名
			方法名要见名知意。（驼峰命名方式）
			方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。
			只要是合法的标识符就行。

		1.4、形式参数列表
			简称：形参
			注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。
			形参的个数是：0~N个。
			public static void sumInt(){}
			public static void sumInt(int x){}
			public static void sumInt(int x, int y){}
			public static void sum(int a, int b, double d, String s){}
			形参有多个的话使用“逗号,”隔开。逗号是英文的。
			形参的数据类型起决定性作用，形参对应的变量名是随意的。

		1.5、方法体：
			由Java语句构成。java语句以“;”结尾。
			方法体当中编写的是业务逻辑代码，完成某个特定功能。
			在方法体中的代码遵循自上而下的顺序依次逐行执行。
			在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。

	2、方法定义之后怎么调用呢？
		方法必须调用才能执行。
		怎么调用，语法是什么？
			类名.方法名(实际参数列表);

		实参和形参的类型必须一一对应，另外个数也要一一对应。



```

## java 中的方法

**1.在方法调用的时候，什么时候可以省略"类名."，什么时候不能省略？**

 a()方法调用 b()方法的时候，a 和 b 方法都在同一个类中，“类名.”可以

 省略。如果不在同一个类中“类名.”不能省略。

**2.什么时候代码会发生重载？**

```
条件1：在同一个类当中
条件2：方法名相同
条件3：参数列表不同
		参数的个数不同算不同
		参数的类型不同算不同
		参数的顺序不同算不同
只要同时满足以上3个条件，那么我们可以认定方法和方法之间发生了重载机制。
	注意：
		不管代码怎么写，最终一定能让java编译器很好的区分开这两个方法。
		方法重载和方法的“返回值类型”无关。
		方法重载和方法的“修饰符列表”无关。

```

## 类的封装

**1.什么是构造方法？**

```
1、什么是构造方法，有什么用？
			构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，
			以及实例变量的初始化。换句话说：构造方法是用来创建对象，并且
			同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统
			会赋默认值。在调用构造方法的时候完成实例变量的赋值初始化）

2、重点（需要记忆）：当一个类没有提供任何构造方法，系统会默认提供
一个无参数的构造方法。（而这个构造方法被称为缺省构造器。）

3、调用构造方法怎么调用呢？
使用哪个运算符呢？
使用new运算符来调用构造方法。
语法格式：
		new 构造方法名(实际参数列表);

4、构造方法的语法结构是？

[修饰符列表] 构造方法名(形式参数列表){
		构造方法体;
		通常在构造方法体当中给属性赋值，完成属性的初始化。
}

注意：
	第一：修饰符列表目前统一写：public。千万不要写public static。

	第二：构造方法名和类名必须一致。

	第三：构造方法不需要指定返回值类型，也不能写void，写上void
			表示普通方法，就不是构造方法了。

普通方法的语法结构是？
	[修饰符列表] 返回值类型 方法名(形式参数列表){
		方法体;
	}

```

**2.为什么不能够将局部变量声明成 static？**

 static 是成员变量及方法的修饰符,是属于类本身的数据字段,在加载类时就已经初始化,为内存中保存.在方法体内声明的只 是局部临时变量,当方法体结束后,这些临时变量会自动销毁,释放缓存空间,所以用 static 来修饰临时变量,是说不过去的!

**3.空指针异常**

```
关于垃圾回收器：GC
		在java语言中，垃圾回收器主要针对的是堆内存。
		当一个java对象没有任何引用指向该对象的时候，
		GC会考虑将该垃圾数据释放回收掉。
出现空指针异常的前提条件是？
		"空引用"访问实例【对象相关】相关的数据时，都会出现空指针异常。
局部变量必须进行初始化才能够进行输出

```

example：

```java
例如：
public class User{
	// 用户id
	// 访问id不能这样：User.id （这是错误的，实例变量不能用类名访问。）
	// id的访问必须先造对象，然后对象有了，才能访问对象的id
	int id; //成员变量，实例变量（对象变量，一个对象一份。）
	// 用户名
	String username; // 成员变量可以不手动赋值，系统赋默认值。
	// 密码
	String password;
	//static 变量 如果不赋值，默认是0；
}

```

4.封装调用

```java
//带有static的方法
//没有static的方法
//分别怎么调用？
	//带有static的方法怎么调用？通过“类名.”的方式访问。

//对象被称为实例。
//实例相关的有：实例变量、实例方法。
//实例变量是对象变量。实例方法是对象方法。
//实例相关的都需要先new对象，通过“引用.”的方式去访问。

建议成员变量都是私有化
当成员变量不是私有化的时候，在外部可以通过类.的方法进行调用（不安全）


// 尝试封装一下
// 不再对外暴露复杂的数据，封装起来
// 对外只提供简单的操作入口。
// 优点：第一数据安全了。第二调用者也方便了。
public class Person{
	// private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。
	// 出了这个类，age属性就无法访问了。私有的。
	private int age; // 每一个人年龄值不同，对象级别的属性。

	// 对外提供简单的访问入口(电视机的遥控器就相当于是电视机的访问入口，简单明了。)
	// 外部程序只能通过调用以下的代码来完成访问
	// 思考：你应该对外提供几个访问入口?
	// 思考：这些操作入口是否应该是方法呢？
	// 写一个方法专门来完成读。(get)
	// 写一个方法专门来完成写。(set)
	// get和set方法应该带有static，还是不应该有static,get和set方法应该定义为实例方法吗？
	// get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）
	// 封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。

//在static方法中无法直接使用成员变量和成员方法

```

## static 关键字

**1.static：**

```
static:
		1、static翻译为“静态”
		2、所有static关键字修饰的都是类相关的，类级别的。
			这也解释了为什么在局部中不能声明static的局部变量的原因
		3、所有static修饰的，都是采用“类名.”的方式访问。
		4、static修饰的变量：静态变量
		5、static修饰的方法：静态方法

变量的分类：
		变量根据声明的位置进行划分：
			在方法体当中声明的变量叫做：局部变量。
			在方法体外声明的变量叫做：成员变量。

成员变量又可以分为：
			实例变量
			静态变量

什么时候变量声明为实例的，什么时候声明为静态的？
		如果这个类型的所有对象的某个属性值都是一样的，
		不建议定义为实例变量，浪费内存空间。建议定义
		为类级别特征，定义为静态变量，在方法区中只保留
		一份，节省内存开销。

	一个对象一份的是实例变量。
	所有对象一份的是静态变量。
当一个对象修改了静态变量的值，那么其他的变量相关的静态变量的值也会被修改
```

**2.static 的初始化**：

```java
静态变量在什么时候初始化？类加载时初始化。
	// 静态变量存储在哪里？方法区
	static int i = 100;

	// 静态代码块什么时候执行？类加载时执行。
	static {
		// 这里可以访问i吗？
		System.out.println("i = " + i);
		可以访问的原因是都是在类加载的时候就进行了初始化
	}
// 实例变量
	int k = 111; // k变量是实例变量，在构造方法执行时内存空间才会开辟。

	static {
		//k变量可以访问吗？
		// static静态代码块在类加载时执行，并且只执行一次。
		// 类加载时，k变量空间还没有开辟出来呢。
		//错误: 无法从静态上下文中引用非静态 变量 k
		//System.out.println("k = " + k);

		// 这里可以访问name吗？
		//错误: 非法前向引用
		// 静态代码块和静态变量都在类加载的时候执行，时间相同，只能靠代码的顺序来决定谁先谁后。
		//System.out.println("name = " + name);
	}

	// 静态变量在静态代码块下面。
	static String name = "zhangsan";

```

**3.java 类何时被加载：**

```
1.main方法被调用的时候，启动main方法的时候会被调用

2.创建类的实例，即new对象的时候

3.创建子类的实例（优先加载父类然后再加载子类）

4.访问类的静态方法和变量的时候类会加载

5.反射：Class.forName();

- java类在以上五种情况下会被加载。
- 在jvm生命周期中每个类如果存在，则不会重复加载。
- 在加载子类的时候会优先加载其父类。
- 类被加载的时候，其中的静态代码块、静态方法及静态变量也会被加载。
- 在初始化某个类时，如果这个类的静态代码块、静态方法或静态变量引用到了另一个类，则这个类也会被加载。
```

**4.什么是 static 代码块**

```java
1、使用static关键字可以定义：静态代码块
2、什么是静态代码块，语法是什么？
	static {
		java语句;
		java语句;
	}
3、static静态代码块在什么时候执行呢？
	类加载时执行。并且只执行一次。
	静态代码块有这样的特征/特点。

4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。

5、静态代码块一般是按照自上而下的顺序执行。

6、静态代码块有啥作用，有什么用？
	第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）
	第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。
	这个时机叫做：类加载时机。

具体的业务：
	项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下
	类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。
	思考：这些记录日志的代码写到哪里呢？
		写到静态代码块当中。

```

**5、总结：**

```
到目前为止，你遇到的所有java程序，有顺序要求的是哪些？
	第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。
	第二：静态代码块1和静态代码块2是有先后顺序的。
    第三：静态代码块和静态变量是有先后顺序的。
```

## this 关键字

```java
1、this是一个关键字，全部小写。
2、this是什么，在内存方面是怎样的？
	一个对象一个this。
	this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
	所以，严格意义上来说，this代表的就是“当前对象”
	this存储在堆内存当中对象的内部。

3、this只能使用在实例方法中。谁调用这个实例方法，this就是谁。
	所以this代表的是：当前对象。

4、“this.”大部分情况下是可以省略的。

5、为什么this不能使用在静态方法中？？？？？？
		this代表当前对象，静态方法中不存在当前对象。

1、this可以使用在实例方法中，不能使用在静态方法中。
2、this关键字大部分情况下可以省略，什么时候不能省略呢？
	在实例方法中，或者构造方法中，为了区分局部变量和实例变量，
这种情况下：this. 是不能省略的



1、this除了可以使用在实例方法中，还可以用在构造方法中。
	2、新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：
		this(实际参数列表);
			通过一个构造方法1去调用构造方法2，可以做到代码复用。
			但需要注意的是：“构造方法1”和“构造方法2” 都是在同一个类当中。

3、this() 这个语法作用是什么？
		代码复用。

4、死记硬背：
  对于this()的调用只能出现在构造方法的第一行。
```

## 继承和多态

**1.多态的基础语法：**

```
1、学习多态基础语法之前，我们需要普及两个概念：
	第一个：向上转型
		子 ---> 父（自动类型转换）
	第二个：向下转型
		父 ---> 子（强制类型转换，需要加强制类型转换符）
	注意：
		java中允许向上转型，也允许向下转型。
		*****（五颗星）无论是向上转型，还是向下转型，
两种类型之间必须有继承关系，没有继承关系编译器报错。
```

**2.多态的含义：**

```
父类型引用指向子类型对象。
包括编译阶段和运行阶段。
编译阶段：绑定父类的方法。
运行阶段：动态绑定子类型对象的方法。
多种形态。
```

**3.什么时候需要向下转型：**

 **当你需要访问子类特有的方法的时候需要进行向下转换。**

**4.没有继承关系的两个类型存在转型嘛？**

```java
// 错误: 不兼容的类型: Dog无法转换为Animal
// Animal a4 = new Dog();

// 调用a2的move()方法
/*
	什么是多态？
		多种形态，多种状态。
	分析：a2.move();
		java程序分为编译阶段和运行阶段。
		先来分析编译阶段：
			对于编译器来说，编译器只知道a2的类型是Animal，
			所以编译器在检查语法的时候，会去Animal.class
			字节码文件中找move()方法，找到了，绑定上move()
		     方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）
		     再来分析运行阶段：
			运行阶段的时候，实际上在堆内存中创建的java对象是
			Cat对象，所以move的时候，真正参与move的对象是一只猫，
			所以运行阶段会动态执行Cat对象的move()方法。这个过程
			属于运行阶段绑定。（运行阶段绑定属于动态绑定。）

多态表示多种形态：
		编译的时候一种形态。
		运行的时候另一种形态。

```

5.分析：

```
// 分析这个程序能否编译和运行呢？
		// 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。
		// 只有编译通过的代码才能运行。没有编译，根本轮不到运行。
		// 错误: 找不到符号
		// why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法
		// 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）
		//a5.catchMouse();

		// 假设代码写到了这里，我非要调用catchMouse()方法怎么办？
		// 这个时候就必须使用“向下转型”了。（强制类型转换）
		// 以下这行代码为啥没报错？？？？
		// 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。
		Cat x = (Cat)a5;
		x.catchMouse(); //猫正在抓老鼠！！！！

```

6.继承的相关特性：
![继承图.png](https://i.loli.net/2020/11/07/SUFi3wVAb6dsxvQ.png)

## 方法覆盖

重要结论：

​	

```java
重要结论：
		当子类对父类继承过来的方法进行“方法覆盖”之后，
		子类对象调用该方法的时候，一定执行覆盖之后的方法。

	当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？
		条件一：两个类必须要有继承关系。
		条件二：重写之后的方法和之前的方法具有：
					相同的返回值类型、
					相同的方法名、
					相同的形式参数列表。
		条件三：访问权限不能更低，可以更高。（这个先记住。）
		条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。（这个先记住）
	
	这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）
		注意1：方法覆盖只是针对于方法，和属性无关。
		注意2：私有方法无法覆盖。
		注意3：构造方法不能被继承，所以构造方法也不能被覆盖。
		注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。
		
		关于Object类中的toString()方法
				1、toString()方法的作用是什么？
					作用：将“java对象”转换成“字符串的形式”。
		
				2、Object类中toString()方法的默认实现是什么？
					public String toString() {
						return getClass().getName() + "@" + Integer.toHexString(hashCode());
					}
					toString: 方法名的意思是转换成String
					含义：调用一个java对象的toString()方法就可以将该java对象转换成字符串的表示形式。
		当输出一个引用的时候，println方法会自动调用引用的toString方法。
		
public static void main(String[] args){
		// 静态方法可以使用“引用.”来调用吗？可以
		// 虽然使用“引用.”来调用，但是和对象无关。
		Animal a = new Cat(); //多态
		// 静态方法和对象无关。
		// 虽然使用“引用.”来调用。但是实际运行的时候还是：Animal.doSome()

```

## super关键字

```
1、super是一个关键字，全部小写。
	2、super和this对比着学习。
		this:
			this能出现在实例方法和构造方法中。
			this的语法是：“this.”、“this()”
			this不能使用在静态方法中。
			this. 大部分情况下是可以省略的。
			this.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。
				public void setName(String name){
					this.name = name;
				}
			this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中
			其它的构造方法，目的是：代码复用。

		super:
			super能出现在实例方法和构造方法中。
			super的语法是：“super.”、“super()”
			super不能使用在静态方法中。
			super. 大部分情况下是可以省略的。
			super.什么时候不能省略呢？ ？？？？？？？
			super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
			的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

	3、super()
		表示通过子类的构造方法调用父类的构造方法。
		模拟现实世界中的这种场景：要想有儿子，需要先有父亲。
	
	4、重要的结论：
		当一个构造方法第一行：
			既没有this()又没有super()的话，默认会有一个super();
			表示通过当前子类的构造方法调用父类的无参数构造方法。
			所以必须保证父类的无参数构造方法是存在的。
	
	5、注意：
		this()和super() 不能共存，它们都是只能出现在构造方法第一行。
	
	6、无论是怎样折腾，父类的构造方法是一定会执行的。（百分百的。）
	
	7、super()默认会出现在子类的构造函数的第一行，虽然没有显示，但默认存在
	
	8.因为当父类提供了有参数的构造函数后就不会提供默认构造函数，这也是为什么让你写出无参构造的原因

```

