# 面向对象

1.面向对象和面向过程的区别：

​	1.1从语言方面出发：

​					对于C语言来说，是完全面向过程的。

​					对于c++来说是半面向对象半面向过程的

​					对于java来说是完全面向对象的。

​	1.2什么是面向过程的开发方式：

​			面向过程的开发方式的主要特点是：

​						注重步骤，注重的是实现这个功能的步骤

​						第一步该干什么，第二步该干什么，面向过程没有对象的概念，只是实现了这个功能的步骤以及因果关系。

​			面向过程的缺点：

​					耦合度高，扩展力差

​					螺栓螺母拧在一起：耦合度高吗？
​					这是耦合度低的，因为螺栓螺母可以再拧开。（它们之间是有接口的。）
​					螺栓螺母拧在一起之后，再用焊条焊接在一起，耦合度高吗？
​					这个耦合度就很高了。耦合度就是黏连程度。
​					往往耦合度高的扩展力就差。

​     	面向过程的优点：快速开发

​				对于小型项目，采用面向过程的方式开发，效率较高。不需要前期进行对象的提取，模型的建立，采用面向过程方式可以直接开始干活，一上来可以直接写代码，编写因果关系，从而实现功能

​		1.3什么是面向对象的开发方式？

​					采用面向对象的方式进行开发，更符合人类的思维方式，面向对象成为主流的原因，人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。

​			面向对象开发的优点：

​						可扩展力强，耦合度低。

#### 当我们采用面向对象的方式贯穿整个系统的话，涉及到三个术语：

OOA: 面向对象分析

OOD：面向对象涉及

OOP：面向对象编程

#### 面向对象的三大特征：封装，继承，多态

##### 类和对象的概念：

1. 面向对象当中最主要“一词”是：对象。

2. 什么是类？

   1. 类在现实世界当中是不存在的，是一个抽象的概念，是一个模板，是我们人类大脑进行“思考，总结，抽象”的一个结果
   2. 类本质上是现实世界当中某些事情具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。

3. 什么是对象？

   1. 对象是实际存在的个体
   2. 在java语言中，要想得到“对象”，必须先定义“类”，“对象”是通过“类”这个模板创造出来的
   3. 类就是一个模板：类描述的是所有对象的“共同特征信息”，对象就是通过类创建出的个体

4. 面向对象的相关术语：

   1. 类：不存在的，人类大脑思考总结的一个模板，这个模板当中描述了共同特征
   2. 对象：实际存在的个体
   3. 实例：对象还有另一个名字叫做实例
   4. 实例化：通过类这个模板创建对象的过程，叫做实例化
   5. 抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程

5. 类=属性+方法

   1. 属性来源于：状态
   2. 方法来源于：动作

6. 查看String类的源码:

   1. F:\jkd-15\lib\src\java.base\java\lang\String.java

   ##### 类的定义

   1. 怎么定义一个类，语法格式是什么？

      ![image.png](https://i.loli.net/2021/01/05/qmvOfJH4bYZBEXL.png)

   2. 对于修饰符列表进行补充：

      1. 类修饰符：

         1. 公共类修饰符 public ： Java 语言中类的访问控制符只有 public 即公共的。每个 Java 程序的有且只有一个类是 public，它被称为主类 ，其他外部类无访问控制修饰符，具有包访问性。注意：一个类的内部类可以被其他访问控制修饰符protected、缺省默认(default、friendly)、private修饰，相当于类的成员。

         2. ***\*非访问控制符：抽象类修饰符 abstract 、最终类修饰符 final\****

              （1）抽象类修饰符 abstract ：用 abstract 修饰符修饰的类，被称为抽象类。

              （2）最终类修饰符 final ：当一个类不能被继承时可用修饰符 final修饰为最终类。被定义为 final 的类通常是一些有固定作用、用来完成某种标准功能的类。

              （3）类缺省访问控制符：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时，这个类只能被同一个包中的类访问或引用。这一访问特性又称为包访问性。

   3. 关于编译过程

      1. 按说应该先编译类，然后在编译测试类，但是对于编译器来说，编译测试类的时候，会自动找类的class文件，如果没有找到就会编译类生成class文件

   4. 对象的创建：

      1. Student s = new Student();
      2. new Student（）这个过程才是对象的创建，s只是个变量名，用来存储对象的引用

   5. 对象和引用的区别：

      1. 对象是new出来的，在堆区存储。
      2. 引用是：但凡是变量，并且改变保存了内存地址指向了堆内存当中的对象的。

   6. 对象和引用的内存图

      ![009-对象和引用.png](https://i.loli.net/2021/01/05/inGYcCWBaMmbUV8.png)

```java
学生类
	学号：int
	姓名：String
	年龄：int
	性别：boolean
	住址：String

变量必须先声明，再赋值才能访问。

注意：对于成员变量来说，没有手动赋值时，系统默认赋值。
赋的值都是默认值，那么默认值是什么？

类型				默认值
---------------------
byte				0
short				0
int					0
long				0L
float				0.0F
double				0.0
boolean				false
char				\u0000
引用数据类型	null

null是一个java关键字，全部小写，表示空。是引用类型的默认值。

分析：对于成员变量来说，是不是应该一个对象有一份。
	李四有李四的学号
	张三有张三的学号
	李四和张三的学号不一样。所以应该有两块不同的内存空间。

*/
public class Student{

	// 属性（描述状态），在java程序中以“成员变量”的形式存在。

	// 学号
	// 一个对象一份。
	int no; // 这种成员变量又被称为“实例变量”。

	// 姓名
	String name;

	// 年龄
	int age;

	// 性别
	boolean sex;

	// 住址
	String addr;

}
			
```
![011-UserTest程序执行内存图.png](https://i.loli.net/2021/01/05/1SwbYFPZ4CatVO5.png)

![012-难度较大-内存图.png](https://i.loli.net/2021/01/05/oy1fDmqsbIESCAX.png)

在java中参数的传递问题：

 java中规定：参数传递的时候，和类型无关，不管是基本数据类型还是引用数据类型
 统一都是将盒子中保存的那个“值”复制一份，传递下去。java中只有一个规定：参数传递的时候，一定是将“盒子”中的东西复制一份传递过去。 内存地址也是值，也是盒子中保存的一个东西。



java中传递引用的内存图

![014-参数传递2.png](https://i.loli.net/2021/01/06/ju3JrPAq1pVoFh4.png)

```java
public class Test2{
	public static void main(String[] args){
		Person p = new Person();
		p.age = 10;
		add(p);
		System.out.println("main--->" + p.age); //11
	}
	// 方法的参数可以是基本数据类型，也可以是引用数据类型，只要是合法的数据类型就行。
	public static void add(Person p){ // p是add方法的局部变量。
		p.age++;
		System.out.println("add--->" + p.age); //11
	}
}

class Person{
	// 年龄属性，成员变量中的实例变量。
	int age;
}
```

### 															构造方法	

1. 什么是构造方法，有什么用？
   1. 构造方法是一个特殊的方法，通过构造方法可以完成对象的创建以及实例变量的初始化，换句话说：构造方法是用来创建对象，并且同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统会赋默认值。）
   2. 重点（需要记忆）：当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法。（而这个构造方法被称为缺省构造器。）
   3. 调用构造方法怎么调用呢？
      	使用哪个运算符呢？
      			使用new运算符来调用构造方法。
      	语法格式：
      			new 构造方法名(实际参数列表);
   4. 构造方法的语法结构是？
      1. [修饰符列表] 构造方法名(形式参数列表){
         				构造方法体;
            				通常在构造方法体当中给属性赋值，完成属性的初始化。
         }
      2. 修饰符列表目前统一写：public。千万不要写public static。
      3. 构造方法名和类名必须一致
      4. 构造方法不需要指定返回值类型，也不能写void，写上void
         表示普通方法，就不是构造方法了。
   5. 当一个类没有提供任何构造方法时，系统默认提供一个无参数的构造方法，建议将无参数构造方法手动的写出来，这样一定不会有问题
   6. 无参数构造方法和有参数构造方法都可以调用
      1. Student s=new Student();
      2. Student s =new Student(15);
   7. 实例变量在构造函数执行时开辟空间，当然也是在构造函数执行的时候给实例变量赋上初值
   8. 对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。



### 																																				封装

1. 什么是封装？封装有什么用？

   ​	封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个	有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。

   1. 保证内部结构的安全
   2. 屏蔽复杂，暴露简单
   3. 属性私有化（使用private关键字进行修饰）
   4. 对外提供简单的操作入口

   ```java
   // 尝试封装一下
   // 不再对外暴露复杂的数据，封装起来
   // 对外只提供简单的操作入口。
   // 优点：第一数据安全了。第二调用者也方便了。
   public class Person{
   	// private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。
   	// 出了这个类，age属性就无法访问了。私有的。
   	private int age; // 每一个人年龄值不同，对象级别的属性。
   
   	// 对外提供简单的访问入口(电视机的遥控器就相当于是电视机的访问入口，简单明了。)
   	// 外部程序只能通过调用以下的代码来完成访问
   	// 思考：你应该对外提供几个访问入口?
   	// 思考：这些操作入口是否应该是方法呢？
   	// 写一个方法专门来完成读。(get)
   	// 写一个方法专门来完成写。(set)
   	// get和set方法应该带有static，还是不应该有static,get和set方法应该定义为实例方法吗？
   	// get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）
   	// 封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。
   
   在static方法中无法直接使用成员变量和成员方法
   
   ```

   ### 																static关键字

   1. static:
      		1、static翻译为“静态”
         		2、所有static关键字修饰的都是类相关的，类级别的。
         		3、所有static修饰的，都是采用“类名.”的方式访问。
         		4、static修饰的变量：静态变量
         		5、static修饰的方法：静态方法
   2. 什么时候定义成静态变量：
      1. 如果这个类型的所有变量的某个属性都是一样的，不建议定义成实例变量，浪费内存空间，建议定义成类级别特征，定义成静态变量，在方法区中只存储一份，节省内存开销
   3. 静态变量的初始化时间：
      - 静态变量是在类加载的时候进行初始化，静态变量存储在方法区当中
   4. 实例相关的一定需要使用"引用."的方式，静态相关的可以使用“类名.”也可以使用“引用.”但是不建议使用“引用.”因为这会对其他程序员造成误导
   5. 什么时候会出现空指针异常：
      1. ***只有“空引用”访问“实例”相关的变量时才会出现空指针异常，即使你用空引用去指向静态方法，但在底层也是用的"类名."的方式去访问静态方法的**



### 																		静态代码块

1. 使用static关键字可以定义：静态代码块
2. 什么是静态代码块，语法是什么？ static{ java语句块；}
3. static静态代码块在类加载的时候执行
4. 静态代码块一般是自上而下的顺序执行
5. 静态代码有什么用？
   1. 静态代码不是那么常用（不是每一个类当中都要写的东西）
   2. 静态代码块这种语法机制实际上是SUN公司为程序员提供的一个时机，这个时机叫做：类加载时机
6. 总结：
   	到目前为止，你遇到的所有java程序，有顺序要求的是哪些？
   		第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。
   		第二：静态代码块1和静态代码块2是有先后顺序的。
   		第三：静态代码块和静态变量是有先后顺序的。

###                                                                           实例语句块

1. 除了静态代码块之外，还有一种语句块叫做：实例语句块

2. 实例语句在类加载时并没有执行。

3. 实例语句块语法？

   1. {

       java语句块；

       java语句块；

      }

4. 实例语句块在什么时候执行？

   1. 只要是构造方法执行，必然在构造方法执行之前，自动会执行实例语句块，这也是SUN公司为程序员准备一个特殊的时机，叫做对象的构建时机



### 																			this关键字

this：
		1、this是一个关键字，全部小写。
		2、this是什么，在内存方面是怎样的？
			一个对象一个this。
			this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
			所以，严格意义上来说，this代表的就是“当前对象”
			this存储在堆内存当中对象的内部。

​		3.this只能使用在实例方法中，谁调用这个实例方法，this就是谁，所有this代表的是当前对象

​		4、“this.” 大部分是可以省略的

​		5、 为什么this不能使用在静态方法中：this代表的是当前对象，静态方法中不存在当前对象

![image.png](https://i.loli.net/2021/01/07/Zam4rjn1OAo3uDh.png)

​		6、this除了可以使用在实例方法中，还可以用在构造方法中。

​				1.新语法：通过当前的构造方法去调用另一个本类的构造方法

​				this（实际参数列表）

​						通过一个构造方法1去调用构造方法2，两个构造方法必须在同一个类当中

​	7、this总结

​				1.this是一个关键字，是一个引用，保存内存地址指向自身。

​				2.this可以使用在实例方法中，也可以使用在构造方法中

​				3.this出现在实例方法中其实代表的就是当前对象

​				4.this不能使用在静态方法中。

​				5.this. 大部分都能够省略，但是用来区分局部变量和实例变量的时候不能省略

​				6.this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。



### 																			继承

1. 继承 extends

   1. 什么是继承，有什么作用？
      1. 继承是一种关系，类似于现实中的子承父业。这就是一种继承
      2. 基本作用：子类继承父类，代码可以得到复用，有了继承关系，才有了后期的方法覆盖和多态机制。
   2. 继承的相关特性
      1. B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。
      2. java 中的继承只支持单继承，不支持多继承，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：class B extends A,C{ } 这是错误的。
      3. 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。
      4.  java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)
      5. java 中的类没有显示的继承任何类，则默认继承 Object类，Object类是 java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有 Object类型中所有的特征。
      6. 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CreditAccount 类

2. toString方法：

   1. toString方法属于Object这个类，因为所有的类都继承Object，所以每个对象都可以调用toString方法。输出对象时，默认调用toString方法

      ```java
       public String toString() {
              return getClass().getName() + "@" + Integer.toHexString(hashCode());
      }
      ```

3.测试：子类继承父类之后，能使用子类对象调用父类方法吗？可以，因为当子类继承了父类后，这个方法就属于子类了，当然可以使用子类对象来调用。

4.在实际开发中，满足什么条件可以使用继承，凡是可以使用“is a” 能描述的都可以继承

​			Cat is a Animal：猫是一个动物
​			Dog is a Animal：狗是一个动物
​			CreditAccount is a Account：信用卡账户是一个银行账户

5.方法的覆盖

1. ​	当父类的方法被继承过来已经无法满足业务需求时，这时就需要对原来的方法进行覆盖

2. 回顾一下方法重载！！！！
   		什么时候考虑使用方法重载overload？
      			当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样
      			代码美观，并且方便编程。

   ```makefile
   	什么条件满足之后能够构成方法重载overload？
   		条件一：在同一个类当中
   		条件二：方法名相同
   		条件三：参数列表不同（个数、顺序、类型）
   
   --------------------------------------------------------------------------------
   
   什么时候我们会考虑使用“方法覆盖”呢？
   	子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时，
   	子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。
   
   方法覆盖又叫做：方法重写（重新编写），英语单词叫做：Override、Overwrite，都可以。
   比较常见的：方法覆盖、方法重写、override
   
   重要结论：
   	当子类对父类继承过来的方法进行“方法覆盖”之后，
   	子类对象调用该方法的时候，一定执行覆盖之后的方法。
   
   当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？
   	条件一：两个类必须要有继承关系。
   	条件二：重写之后的方法和之前的方法具有：
   				相同的返回值类型、
   				相同的方法名、
   				相同的形式参数列表。
   	条件三：访问权限不能更低，可以更高。（这个先记住。）
   	public protected private 权限是从高到低
   	条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。（这个先记住）
   
   这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）
   	注意1：方法覆盖只是针对于方法，和属性无关。
   	注意2：私有方法无法覆盖。
   	注意3：构造方法不能被继承，所以构造方法也不能被覆盖。
   	注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。
   ```



## 																			多态

### 多态的基础语法

1. 向上类型转换和向下类型转化：
   1. 向上转型：从子到父 自动类型转换
   2. 向下转型：从父到子  强制类型转换
2. 无论是向上转型还是向下转型，必须要有继承关系
3. 多态指的是：
   1. 父类型的引用指向了子类型的对象，包括编译阶段和运行阶段
   2. 编译阶段绑定父类型的方法
   3. 运行阶段动态绑定子类型对象的方法

   4.向下转型存在风险吗？

​		   1.当两个类之间没有存在继承关系的时候，会出现ClassCastException异常

​			2.为了避免ClassCastException异常会使用instanceof关键字

​			3.语法：引用 instanceof 类型 为真返回true，为假返回false。

```java
package 数据结构;
public class Review{
    public static void main(String[] args) {
        Animal ani=new Animal();
        ani.eat(); //动物正在吃饭
        // 小鸟和动物具有继承关系，满足语法条件
        Animal bird=new Bird(); //小鸟正在吃饭
        // 分析bird.eat()方法：
//        对于编译阶段：
//            编译只知道bird是一个Animal类型，所以编译的时候会去Animal.class文件去找eat()方法，找到了，
//            绑定上eat方法编译通过，静态绑定成功
//        对于运行阶段：
//              运行的时候，实际上在堆内存中创建的java对象是Bird对象，
//              所以eat的时候，真正参与eat的是一只鸟，所以运行阶段会动态的执行Bird对象的eat方法，这个过程属于运行阶段绑定。
        bird.eat();

        // 当想要调用子类中独有的方法时，必须向下转型，进行强制类型转换
        if(bird instanceof Bird){
            Bird b=(Bird)bird;
            b.catchMouse();
        }

        Animal cat=new Cat(); //小猫正在吃饭
        cat.eat();


    }
}
class Animal{
    public void eat(){
        System.out.println("动物正在吃饭");
    }
}
class Cat extends Animal{
    public void eat(){
        System.out.println("小猫正在吃饭");
    }
}
class Bird extends Animal{
    public void eat(){
        System.out.println("小鸟正在吃饭");
    }
    public void catchMouse(){
        System.out.println("小鸟正在捉老鼠");
    }
}
```

### super关键字

super能出现在实例方法和构造方法中。

```text
super的语法是：“super.”、“super()”

super不能使用在静态方法中。

super. 大部分情况下是可以省略的。

super.什么时候不能省略呢？
	父类和子类中有同名属性，或者说有同样的方法，
	想在子类中访问父类的，super. 不能省略。

super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

super的使用：
	super.属性名				【访问父类的属性】
	super.方法名(实参)		【访问父类的方法】
	super(实参)					【调用父类的构造方法】
```

